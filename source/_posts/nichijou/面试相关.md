面试相关: 

1. 只有静态内部内才可以有静态变量, 非静态不可以, 非静态jvm在加载父类并不会初始化内部类.
2. Try-finally-return
   1. finally语句一定会执行
   2. 如果在try和catch, finally中都有return语句, 那么最终返回的是finally的返回值. 因为finally一定会执行, 而执行到return语句后就会返回, 所以jvm会在try和catch返回之前执行finally, 所以会返回finally中的return.

3. 序列化Serizalizable实现接口标记可将对象转换成一个字节数组, 并从字节数据恢复对象.
   1. 使用serialVersionUID验证一致性. 如果不一致抛出异常. 如果不指定该id, 那么如果反序列化之前修改了类的结构, 会报错. 如果指定了id且修改了属性, 反序列化可能恢复部分数据, 也可能恢复不了数据.
4. 对象深拷贝和浅拷贝
   1. 实现Cloneable接口, 标记可以调用clone方法. clone方法是定义在Object对象中的. 
   2. 实现深拷贝可以重新定义对象, 并拷贝值到新建的对象中, 并返回. 也可以通过序列化机制进行深拷贝. 通过ObjectOutPutStream, ObjectInputStream进行实现.
5. BIO: 
6. 异常:
   1. 顶层是Trowable接口, 主要分为2类: Error和Exception
   2. Error是程序无法处理的异常, 有JVM产生抛出, 比如OutOfMemoryError和StackOverFlowError. 
   3. Exception是程序可以处理的异常, 分为两大类: 受检异常和非受检异常(运行时异常和非运行时异常). 
   4. 受检异常必须进行try-catch或throw, 常见的受检异常: ClassNotFoundException, IOExcetion, InterruptedException
   5. 非受检异常不需要进行try-catch和trow, 常见非受检异常: NullPointerException, IndexOutOfBoundException, ArithemeticException, ClassCastException, NumberFormatException
7. 泛型
   1. ? 通配符 pecs(prodecer extends consumer super)
   2. ? extends T, 只能知道?的类是继承自T的, 不知道存的具体类型是什么, 可能是子类, 所以不能增加, 但是可以取出来, 因为是T的子类, 取出的元素可以转为T类, 或者T的父类型.
   3. ? super T, 可以用于存放, 因为不知道?是T的具体哪一个父类, 所以取出来的时候只能是Object类型, 因为Object是所有类的父类. 但是存放的时候只要是T及其子类都可以存放, 因为T及其子类一定有相同的父类.
   4. 泛型擦除, 编译时会将泛型擦除为限定类型, 如果没有限定类型就使用Object.

8. 设计原则
   1. 单一职责原则: 一个类只做一件事情
   2. 里式替换原则: 任何使用父类的地方, 都可以使用子类去替换
   3. 依赖倒置/面向接口编程: 高层模块不依赖底层模块具体实现, 都依赖其抽象, 抽象不依赖细节, 细节依赖于抽象.
   4. 接口隔离原则: 使用多个专门的接口代替一个统一的接口.
   5. 迪米特法则: 一个类对依赖的类知道的越少越好. 即依赖的类应该将负责的逻辑封装在内部.
   6. 开闭原则: 多拓展开放, 对实现关闭
   7. 合成复用原则: 多使用组合和聚合, 少使用继承
9. 设计模式
   1. 代理模式是对被代理者的功能的增强. 装饰器是对被装饰者添加额外的功能. 适配器是将一个接口转换成另一个合适的接口.
   2. 工厂模式
   3. 抽象工厂模式
   4. 单例模式
   5. 构造者模式
10. JDK中的设计模式
    1. 构造器模式: StringBuilder
    2. 装饰器模式: io中的一系列实现
    3. 代理模式: 动态代理 InvocationHandler
    4. 策略模式: Comparator
    5. 模板方法模式: AbstractList, AbstractMap等
    6. 迭代器模式: Iterator
    7. 责任链: Filter
11. Spring中的设计模式
    1. 抽象工厂: BeanFactory
    2. 代理: Aop
    3. 模板方法: AbstractApplicationContext
    4. 单例模式: Spring默认创建的对象就是单例模式

