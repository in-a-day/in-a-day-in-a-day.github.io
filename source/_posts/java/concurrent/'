---
title: Thread类详解
tags:
  - java
  - 多线程
categories: java
date: 2021-03-04 15:01:08
---

## Thread
一个`Thread`就是一个在程序中执行的线程. JVM允许一个应用有多个并发执行的线程.  
每个线程都有一个优先级, 优先级高的线程优先于优先级低的线程执行(并不是绝对的).
一个线程可能是守护线程. 当新建一个`Thread`对象时, 该对象的优先级继承自创建该对象的线程的优先级. 如果创建线程是守护线程, 那么该新线程也是守护线程.  
JVM启动时, 通常只有一个非守护线程(调用指定类的main方法). 发生以下情况时, JVM停止执行线程:
- 调用了`Runtime`类的exit方法, 并且安全管理器允许执行退出操作.
- 所有的非守护线程全部结束, 或者从`run`方法调用中返回, 或者从`run`方法中抛出了异常.

### **Thread构造方法**
下面看一下Thread的构造方法, 可以看到构造函数中可以有一下参数:  
- ThreadGroup group: 指定线程所属线程组
- Runnable target: 需要运行的线程方法
- String name: 线程的名称
- long stackSize: 线程栈期望的大小(实际大小有JVM决定)
所有构造方法都是调用了类中的init方法. 
```java
    public Thread() {
        init(null, null, "Thread-" + nextThreadNum(), 0);
    }

    public Thread(Runnable target) {
        init(null, target, "Thread-" + nextThreadNum(), 0);
    }

    Thread(Runnable target, AccessControlContext acc) {
        init(null, target, "Thread-" + nextThreadNum(), 0, acc, false);
    }

    public Thread(ThreadGroup group, Runnable target) {
        init(group, target, "Thread-" + nextThreadNum(), 0);
    }

    public Thread(String name) {
        init(null, null, name, 0);
    }

    public Thread(ThreadGroup group, String name) {
        init(group, null, name, 0);
    }

    public Thread(Runnable target, String name) {
        init(null, target, name, 0);
    }

    public Thread(ThreadGroup group, Runnable target, String name) {
        init(group, target, name, 0);
    }

    public Thread(ThreadGroup group, Runnable target, String name,
                  long stackSize) {
        init(group, target, name, stackSize);
    }
```

```java
private void init(ThreadGroup g, Runnable target, String name,
				  long stackSize) {
	init(g, target, name, stackSize, null, true);
}

/**
 * Initializes a Thread.
 *
 * @param g the Thread group
 * @param target the object whose run() method gets called
 * @param name the name of the new Thread
 * @param stackSize the desired stack size for the new thread, or
 *        zero to indicate that this parameter is to be ignored.
 * @param acc the AccessControlContext to inherit, or
 *            AccessController.getContext() if null
 * @param inheritThreadLocals if {@code true}, inherit initial values for
 *            inheritable thread-locals from the constructing thread
 */
private void init(ThreadGroup g, Runnable target, String name,
				  long stackSize, AccessControlContext acc,
				  boolean inheritThreadLocals) {
	if (name == null) {
		throw new NullPointerException("name cannot be null");
	}

	this.name = name;

	Thread parent = currentThread();
	SecurityManager security = System.getSecurityManager();
	if (g == null) {
		/* Determine if it's an applet or not */

		/* If there is a security manager, ask the security manager
		   what to do. */
		if (security != null) {
			g = security.getThreadGroup();
		}

		/* If the security doesn't have a strong opinion of the matter
		   use the parent thread group. */
		if (g == null) {
			g = parent.getThreadGroup();
		}
	}

	/* checkAccess regardless of whether or not threadgroup is
	   explicitly passed in. */
	g.checkAccess();

	/*
	 * Do we have the required permissions?
	 */
	if (security != null) {
		if (isCCLOverridden(getClass())) {
			security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
		}
	}

	g.addUnstarted();

	this.group = g;
	this.daemon = parent.isDaemon();
	this.priority = parent.getPriority();
	if (security == null || isCCLOverridden(parent.getClass()))
		this.contextClassLoader = parent.getContextClassLoader();
	else
		this.contextClassLoader = parent.contextClassLoader;
	this.inheritedAccessControlContext =
			acc != null ? acc : AccessController.getContext();
	this.target = target;
	setPriority(priority);
	if (inheritThreadLocals && parent.inheritableThreadLocals != null)
		this.inheritableThreadLocals =
			ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
	/* Stash the specified stack size in case the VM cares */
	this.stackSize = stackSize;

	/* Set thread ID */
	tid = nextThreadID();
}
```


