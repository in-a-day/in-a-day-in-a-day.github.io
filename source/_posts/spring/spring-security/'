---
title: Spring Security Authentication(认证)(5.4.5)
tags:
  - java
  - spring
  - spring security
categories: spring
date: 2021-03-24 23:08:00
---
Spring Security为认证提供了全面的支持. 接下来从这两个方面进行介绍:
## **架构组件(Architecture Components)**
主要描述Spring Security用于Servlet认证中的架构组件. 主要有以下组件:
- `SecurityContextHolder`: 存储身份验证详细信息的地方.
- `SecurityContext`: 由`SecurityContextHolder`获得,包含了当前认证客户的`Authentication`.
- `Authentication`: 可以是`AuthenticationManager`的输入, 以提供用户提供的用于身份验证的凭据或来自SecurityContext的当前用户.
- `GrantedAuthority`: 授予身份验证主体的权限(即角色, 范围等).
- `AuthenticationManager`: 定义了Spring Security的Filters如何进行认证的API.
- `ProviderManager`: `AuthenticationManager`的一个通用实现.
- `Request Credentails with AuthenticationEntryPoint`: 用于从客户端请求凭证(即重定向到登录页面, 发送WWW-Authenticate响应等).
- `AbstractAuthenticationProcessingFilter`: 用于认证的基础Filter. 这样为高级别的身份认证流程和各个部件如何协同工作提供了一个好的概念.

## **认证机制(Authentication Mechanisms)**
- Username and Password - 如何使用用户名密码认证
- OAuth 2.0 Login - OAhth 2.0 使用OpenID Connect登录和非标准的OAuth 2.0 登录(即GitHub)
- SAML 2.0 Login - SAML 2.0 登录
- Central Authentication Server (CAS) - CAS支持
- Remember Me - 如何记住用户
- JAAS Authentication - JAAS认证
- OpenID - OpenID 认证 (不要与OpenID Connect弄混)
- Pre-Authentication Scenarios - 使用外部机制进行认证(e.g. SiteMider或J2EE security), 但仍使用Spring Security授权和防范常见漏洞攻击.
- X509 Authentication - X509 认证

## **SecurityContextHolder**
`SecurityContextHolder`是Spring Security认证模型的核心. 它包含了`SecurityContext`.
![SecurityContextHolder](https://cdn.jsdelivr.net/gh/in-a-day/cdn@main/images/java/spring/spring-security/filterchain.png)_SecurityContextHolder_
上图可以看出, `SecurityContextHolder`中包含了`SecurityContext`, `SecurityContext`中包含了`Authentication`, `Authentication`中包含了`Principal, Credentials, Authorities`.

`SecurityContextHolder`存储了身份认证的详细信息. Spring Security不关心`SecurityContextHolder`是如何填充的. 如果他包含了值, 就将它当做当前认证的用户.

表示客户已经通过认证的最简单的方式是直接设置`SecurityContextHolder`. 下面展示了如何使用:
```java
SecurityContext context = SecurityContextHolder.createEmptyContext();  // 1
Authentication authentication = new TestingAuthenticationToken("name", "pwd", "ROLE_USER");  // 2
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context);  // 3
```
- 1. 此处创建一个新的`SecurityContext`而不是使用`SecurityContextHolder.getContext().setAuthentication(authentication)`, 避免了多线程的条件竞争.
- 2. 接着创建一个新的`Authentication`对象. Spring Security不关心在`SecurityContext`中设置什么类型的`Authentication`实现. 此处使用测试用的`TestingAuthenticationToken`(实现简单). 通常情况下生产环境使用`UsernamePasswordAuthenticationToken(userDetails, password, authorities)`.
- 3. 最后在`SecurityContextHolder`中设置`SecurityContext`.

通过`SecurityContextHolder`获取已验证的principal.
```java
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
```

默认情况下`SecurityContextHolder`使用`ThreadLocal`存储这些详细信息, 这意味着`SecurityContext`对同一线程中的方法都是可用的, 即使`SecurityContext`没有显示地作为参数传递给这些方法. Spring Security的`FilterChainProxy`确保`SecurityContext`在线程请求后正确的被清理, 所以使用以这种方式使用`ThreadLocal`是安全的.

有些应用不适合使用`ThreadLocal`(例如Swing), 所以`SecurityContextHolder`可以在启动时配置一个策略以执行上下文如何存储. 包含以下策略:
- MODE_THREADLOCAL
- MODE_INHERITABLETHREADLOCAL
- MODE_GLOBAL

`SecurityContextHolder`源码如下:
```java
public class SecurityContextHolder {

	public static final String MODE_THREADLOCAL = "MODE_THREADLOCAL";

	public static final String MODE_INHERITABLETHREADLOCAL = "MODE_INHERITABLETHREADLOCAL";

	public static final String MODE_GLOBAL = "MODE_GLOBAL";

	public static final String SYSTEM_PROPERTY = "spring.security.strategy";

	private static String strategyName = System.getProperty(SYSTEM_PROPERTY);

	private static SecurityContextHolderStrategy strategy;

	private static int initializeCount = 0;

	static {
		initialize();
	}

	private static void initialize() {
		if (!StringUtils.hasText(strategyName)) {
			// Set default
			strategyName = MODE_THREADLOCAL;
		}
		if (strategyName.equals(MODE_THREADLOCAL)) {
			strategy = new ThreadLocalSecurityContextHolderStrategy();
		}
		else if (strategyName.equals(MODE_INHERITABLETHREADLOCAL)) {
			strategy = new InheritableThreadLocalSecurityContextHolderStrategy();
		}
		else if (strategyName.equals(MODE_GLOBAL)) {
			strategy = new GlobalSecurityContextHolderStrategy();
		}
		else {
			// Try to load a custom strategy
			try {
				Class<?> clazz = Class.forName(strategyName);
				Constructor<?> customStrategy = clazz.getConstructor();
				strategy = (SecurityContextHolderStrategy) customStrategy.newInstance();
			}
			catch (Exception ex) {
				ReflectionUtils.handleReflectionException(ex);
			}
		}
		initializeCount++;
	}

	/**
	 * Explicitly clears the context value from the current thread.
	 */
	public static void clearContext() {
		strategy.clearContext();
	}

	/**
	 * Obtain the current <code>SecurityContext</code>.
	 * @return the security context (never <code>null</code>)
	 */
	public static SecurityContext getContext() {
		return strategy.getContext();
	}

	/**
	 * Primarily for troubleshooting purposes, this method shows how many times the class
	 * has re-initialized its <code>SecurityContextHolderStrategy</code>.
	 * @return the count (should be one unless you've called
	 * {@link #setStrategyName(String)} to switch to an alternate strategy.
	 */
	public static int getInitializeCount() {
		return initializeCount;
	}

	/**
	 * Associates a new <code>SecurityContext</code> with the current thread of execution.
	 * @param context the new <code>SecurityContext</code> (may not be <code>null</code>)
	 */
	public static void setContext(SecurityContext context) {
		strategy.setContext(context);
	}

	/**
	 * Changes the preferred strategy. Do <em>NOT</em> call this method more than once for
	 * a given JVM, as it will re-initialize the strategy and adversely affect any
	 * existing threads using the old strategy.
	 * @param strategyName the fully qualified class name of the strategy that should be
	 * used.
	 */
	public static void setStrategyName(String strategyName) {
		SecurityContextHolder.strategyName = strategyName;
		initialize();
	}

	/**
	 * Allows retrieval of the context strategy. See SEC-1188.
	 * @return the configured strategy for storing the security context.
	 */
	public static SecurityContextHolderStrategy getContextHolderStrategy() {
		return strategy;
	}

	/**
	 * Delegates the creation of a new, empty context to the configured strategy.
	 */
	public static SecurityContext createEmptyContext() {
		return strategy.createEmptyContext();
	}

	@Override
	public String toString() {
		return "SecurityContextHolder[strategy='" + strategyName + "'; initializeCount=" + initializeCount + "]";
	}

}
```

## **SecurityContext**
> `SecurityContext`可以从`SecurityContextHolder`中获得. 其包含了一个`Authenticaiton`对象.

源码如下:
```java
public interface SecurityContext extends Serializable {

	/**
	 * Obtains the currently authenticated principal, or an authentication request token.
	 * @return the <code>Authentication</code> or <code>null</code> if no authentication
	 * information is available
	 */
	Authentication getAuthentication();

	/**
	 * Changes the currently authenticated principal, or removes the authentication
	 * information.
	 * @param authentication the new <code>Authentication</code> token, or
	 * <code>null</code> if no further authentication information should be stored
	 */
	void setAuthentication(Authentication authentication);

}
```

## **Authentication**
`Authentication`在Spring Security中主要有以下两个目的:
- 作为`AuthenticationManager`的输出, 提供用户提供的身份认证凭据. 这种情况下, `isAuthenticated()`将返回`false`.
- 表示当前认证的用户. 可以从`SecurityContext`中获取当前的`Authentication`.

`Authentication`主要包含以下属性:
- `principal` - 标识用户. 当使用用户名/密码进行身份认证时, 通常是一个`UserDetails`的一个实例.
- `credentials` - 通常是密码. 多数情况下, 在用户完成身份认证后会被清除, 以保证不会泄露.
- `authorities` - `GrantedAuthority`是用户被授予的高级权限. 例如角色或领域(roles or scops).

`Authentication`源码:
```java
public interface Authentication extends Principal, Serializable {

	/**
	 * Set by an <code>AuthenticationManager</code> to indicate the authorities that the
	 * principal has been granted. Note that classes should not rely on this value as
	 * being valid unless it has been set by a trusted <code>AuthenticationManager</code>.
	 * <p>
	 * Implementations should ensure that modifications to the returned collection array
	 * do not affect the state of the Authentication object, or use an unmodifiable
	 * instance.
	 * </p>
	 * @return the authorities granted to the principal, or an empty collection if the
	 * token has not been authenticated. Never null.
	 */
	Collection<? extends GrantedAuthority> getAuthorities();

	/**
	 * The credentials that prove the principal is correct. This is usually a password,
	 * but could be anything relevant to the <code>AuthenticationManager</code>. Callers
	 * are expected to populate the credentials.
	 * @return the credentials that prove the identity of the <code>Principal</code>
	 */
	Object getCredentials();

	/**
	 * Stores additional details about the authentication request. These might be an IP
	 * address, certificate serial number etc.
	 * @return additional details about the authentication request, or <code>null</code>
	 * if not used
	 */
	Object getDetails();

	/**
	 * The identity of the principal being authenticated. In the case of an authentication
	 * request with username and password, this would be the username. Callers are
	 * expected to populate the principal for an authentication request.
	 * <p>
	 * The <tt>AuthenticationManager</tt> implementation will often return an
	 * <tt>Authentication</tt> containing richer information as the principal for use by
	 * the application. Many of the authentication providers will create a
	 * {@code UserDetails} object as the principal.
	 * @return the <code>Principal</code> being authenticated or the authenticated
	 * principal after authentication.
	 */
	Object getPrincipal();

	/**
	 * Used to indicate to {@code AbstractSecurityInterceptor} whether it should present
	 * the authentication token to the <code>AuthenticationManager</code>. Typically an
	 * <code>AuthenticationManager</code> (or, more often, one of its
	 * <code>AuthenticationProvider</code>s) will return an immutable authentication token
	 * after successful authentication, in which case that token can safely return
	 * <code>true</code> to this method. Returning <code>true</code> will improve
	 * performance, as calling the <code>AuthenticationManager</code> for every request
	 * will no longer be necessary.
	 * <p>
	 * For security reasons, implementations of this interface should be very careful
	 * about returning <code>true</code> from this method unless they are either
	 * immutable, or have some way of ensuring the properties have not been changed since
	 * original creation.
	 * @return true if the token has been authenticated and the
	 * <code>AbstractSecurityInterceptor</code> does not need to present the token to the
	 * <code>AuthenticationManager</code> again for re-authentication.
	 */
	boolean isAuthenticated();

	/**
	 * See {@link #isAuthenticated()} for a full description.
	 * <p>
	 * Implementations should <b>always</b> allow this method to be called with a
	 * <code>false</code> parameter, as this is used by various classes to specify the
	 * authentication token should not be trusted. If an implementation wishes to reject
	 * an invocation with a <code>true</code> parameter (which would indicate the
	 * authentication token is trusted - a potential security risk) the implementation
	 * should throw an {@link IllegalArgumentException}.
	 * @param isAuthenticated <code>true</code> if the token should be trusted (which may
	 * result in an exception) or <code>false</code> if the token should not be trusted
	 * @throws IllegalArgumentException if an attempt to make the authentication token
	 * trusted (by passing <code>true</code> as the argument) is rejected due to the
	 * implementation being immutable or implementing its own alternative approach to
	 * {@link #isAuthenticated()}
	 */
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;

}
```

## **GrantedAuthority**
`GrantedAuthority`是用户被授予的高级权限. 例如roles或scopes.

通过`Authentication.getAuthorities()`可以获得`GrantedAuthority`集合. `GrantedAuthority`就是授予用户的权限. 通常称这些权限为角色, 例如`ROLE_ADMINISTRATOR, ROLE_HR_SUPERVISOR`. 这些角色可以用于配置web授权, 方法授权和domain对象授权. 使用用户名/密码方式认证的`GrantedAuthority`通常由`UserDetaiLService`加载. 

源码如下:
```java
public interface GrantedAuthority extends Serializable {

	/**
	 * If the <code>GrantedAuthority</code> can be represented as a <code>String</code>
	 * and that <code>String</code> is sufficient in precision to be relied upon for an
	 * access control decision by an {@link AccessDecisionManager} (or delegate), this
	 * method should return such a <code>String</code>.
	 * <p>
	 * If the <code>GrantedAuthority</code> cannot be expressed with sufficient precision
	 * as a <code>String</code>, <code>null</code> should be returned. Returning
	 * <code>null</code> will require an <code>AccessDecisionManager</code> (or delegate)
	 * to specifically support the <code>GrantedAuthority</code> implementation, so
	 * returning <code>null</code> should be avoided nless actually required.
	 * @return a representation of the granted authority (or <code>null</code> if the
	 * granted authority cannot be expressed as a <code>String</code> with sufficient
	 * precision).
	 */
	String getAuthority();

}
```

## **AuthenticationManager**
`AuthenticationManager`是定义Spring Security的Filter如何执行认证的API. 在控制器中(即Spring Security的Filter)中调用`AuthenticationManager`将返回的`Authentication`设置到`SecurityContextHolder`中. 如果没有集成Spring Security’s Filters, 也可以直接设置`SecurityContextHolder`而不适用`AuthenticationManager`.

尽管`AuthenticationManager`的实现可以是任意的, 但是最通用的实现是`ProviderManager`.

源码如下:
```java
public interface AuthenticationManager {

	/**
	 * Attempts to authenticate the passed {@link Authentication} object, returning a
	 * fully populated <code>Authentication</code> object (including granted authorities)
	 * if successful.
	 * <p>
	 * An <code>AuthenticationManager</code> must honour the following contract concerning
	 * exceptions:
	 * <ul>
	 * <li>A {@link DisabledException} must be thrown if an account is disabled and the
	 * <code>AuthenticationManager</code> can test for this state.</li>
	 * <li>A {@link LockedException} must be thrown if an account is locked and the
	 * <code>AuthenticationManager</code> can test for account locking.</li>
	 * <li>A {@link BadCredentialsException} must be thrown if incorrect credentials are
	 * presented. Whilst the above exceptions are optional, an
	 * <code>AuthenticationManager</code> must <B>always</B> test credentials.</li>
	 * </ul>
	 * Exceptions should be tested for and if applicable thrown in the order expressed
	 * above (i.e. if an account is disabled or locked, the authentication request is
	 * immediately rejected and the credentials testing process is not performed). This
	 * prevents credentials being tested against disabled or locked accounts.
	 * @param authentication the authentication request object
	 * @return a fully authenticated object including credentials
	 * @throws AuthenticationException if authentication fails
	 */
	Authentication authenticate(Authentication authentication) throws AuthenticationException;

}
```

## **ProviderManager**
`ProviderManager`是`AuthenticationManager`的一个最常用的实现. `ProviderManager`委托给`AuthenticationProvider`列表进行认证.



