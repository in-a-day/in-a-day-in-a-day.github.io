---
title: 常用注解
tags:
  - java
  - spring
categories: spring
date: 2021-02-28 23:45:58
---

## **组件添加相关注解及接口**
### **@Configuration**
> 表示当前类是一个配置文件类
### **@ComponentScan**
> 配置包扫描(扫描@Configuration及继承自@Configuration注解的注解).  

- **basePackages属性使用**
```java
@Configuration
// 表示扫描com.nichijou包下的所有组件
@ComponentScan("com.nichijou")
public class MyScan {
}
```

- **basePackageClasses: 扫描的类**
```java
@Configuration
// 表示仅添加AA和BB类
@ComponentScan(basePackageClasses = {AA.class, BB.class})
public class MyScan {
}
```

- **includeFilters: 包含匹配规则**
```java
// 表示使用注解匹配, 所有标注@Service注解的都进行注册
@ComponentScan(includeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Service.class})
}, useDefaultFilters = false)
public class ComponentScanAnnotation {
```

- **excludeFilters: 排除匹配规则**
```java
// 表示使用注解匹配, 所有标注@Controller注解的都不进行注册
@ComponentScan(excludeFilters = {
        @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = {Controller.class})
}, useDefaultFilters = false)
public class ComponentScanAnnotation {
```

- **ComponentScan注解定义:**
```java
public @interface ComponentScan {

    // 全限定包名, 将会扫描包下的所有组件
	@AliasFor("basePackages")
	String[] value() default {};

	@AliasFor("value")
	String[] basePackages() default {};

    // 全限定类名, 只扫描指定的类
	Class<?>[] basePackageClasses() default {};

    // 组件添加到容器中的名称生成器
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;

    // 扫描添加的组件是否使用代理
	Class<? extends ScopeMetadataResolver> scopeResolver() default AnnotationScopeMetadataResolver.class;

	ScopedProxyMode scopedProxy() default ScopedProxyMode.DEFAULT;

	String resourcePattern() default ClassPathScanningCandidateComponentProvider.DEFAULT_RESOURCE_PATTERN;

    // 是否使用默认过滤
	boolean useDefaultFilters() default true;

    // 包含过滤规则, 根据该规则查找需要注入的组件
	Filter[] includeFilters() default {};

    // 排除过滤规则, 根据该规则查找需要排除的组件
	Filter[] excludeFilters() default {};

    // 扫描添加的组件是否懒加载
	boolean lazyInit() default false;

	@Retention(RetentionPolicy.RUNTIME)
	@Target({})
	@interface Filter {

        // 默认是以Annotation规则排除
		FilterType type() default FilterType.ANNOTATION;

		@AliasFor("classes")
		Class<?>[] value() default {};

		@AliasFor("value")
		Class<?>[] classes() default {};

		String[] pattern() default {};
	}
}
```


### **@Bean**
> 作用于方法上, 表示方法产生一个Spring管理的组件.

常用属性:
1. **指定bean名称**
```java
@Configuration
public class MyBean {
    // 默认使用方法名称作为组件名称, 即car
    @Bean
    public Car car() {
        return new Car();
    }

    // 通过name或value指定bean名称 
    // @Bean(name = "myCar")
    @Bean("myCar")
    public Car getCar() {
        return new Car();
    }
}
```
2. **指定bean初始化和销毁方法**
```java
// 指定Car()中init和destroy方法作为初始化和销毁方法
@Bean(initMethod="init", destoryMethod()="destory")
public Car car() {
    return new Car();
}
```

3. **@Bean源码**
```java
@Target({ElementType.METHOD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Bean {

	@AliasFor("name")
	String[] value() default {};

    // 指定bean的名称, 可以有多个
	@AliasFor("value")
	String[] name() default {};

    // 废弃, 是否可以通过名称和类型查找自动注入
    @Deprecated
	Autowire autowire() default Autowire.NO;

    // TODO
	boolean autowireCandidate() default true;

    // 指定bean的初始化方法
	String initMethod() default "";

    // 指定bean的销毁方法
	String destroyMethod() default AbstractBeanDefinition.INFER_METHOD;
}
```


### **@Component**
> 表示当前类是Spring的一个组件
```java
@Component
public class Car() {
}
```
### **@Service**
> 表示当前类是Service层

### **@Controller**
> 表示当前类是Controller层

### **@Repository**
> 表示当前类是Dao层

### **@Conditional**
> 作用于类型和方法上, 表示仅在满足条件的情况下才注册组件. 在spring boot底层中大量使用.使用时需要实现Condition接口.

- **Conditional注解源码**:
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
	Class<? extends Condition>[] value();
}
```
- **Condition接口的定义:**
```java
@FunctionalInterface
public interface Condition {
    // 返回true表示当前组件可以被注册到容器中, false反之.
	boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata);

}
```
- 例子:
```java
// 由于无Controller注解将不会注册到容器中
@Conditional(MyCondition.class)
public class Car() {
}

public class MyCondition implements Condition () {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        // 表示有Controller注解才会将组件注册到容器中
        return metadata.isAnnotated("Controller");
    };
}
```


### @Lazy
> 懒加载, 使用范围: @Target({ElementType.TYPE, ElementType.METHOD, ElementType.CONSTRUCTOR, ElementType.PARAMETER, ElementType.FIELD})

### @Scope
> bean的作用域
- 可选作用域
    - singleton: 单例, 默认模式
    - prototype: 原型, 即多例
    - request: web容器中才有, 每个请求新建一个组件
    - session: web容器才有, 每个请求新建一个组件
- **源码**
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Scope {
	@AliasFor("scopeName")
	String value() default "";

    // 作用域名称
	@AliasFor("value")
    String scopeName() default "";

    // 作用域代理模式
	ScopedProxyMode proxyMode() default ScopedProxyMode.DEFAULT;

}
```


### @Import
> 快速将组件注册到容器中. 假设引用了第三发jar包, 我们无法修改jar包中的类, 可以使用@Bean注解手动注册组件, 也可以使用@Import快速注册.
**只可以用于类型上.**

#### 使用方式:
##### 直接导入类:
```java
@Configuration
// 默认调用的是无参的构造参数进行注册, 默认组件名称为全限定类名.
@Import(ThirdClass2.class)
public class Config() {
    public ThirdClass1 getThird1() {
        return new ThirdClass1();
    }
}
```
##### 导入其他配置类
导入其他配置类, 也可以使用@Import注解导入其他配置类, 会将其他配置类中的组件注册到容器中.
```java
@Configuration
@Import(OtherConf.class)
public class Conf {
}

public class OtherConf {
    @Bean
    public Car getCar() {
        return new Car();
    }
}
```
##### 导入ImportSelector实现类
实现ImportSelector接口, 返回需要导入类的全限定类名.  
ImportSelector接口定义:
```java
public interface ImportSelector {

    // 返回需要注册到容器的组件的全限定类名
	String[] selectImports(AnnotationMetadata importingClassMetadata);

	@Nullable
	default Predicate<String> getExclusionFilter() {
		return null;
	}
}
```
ImportSelector接口使用:
```java
@Configuration
@Import(MyImportSelector.class)
public class Conf() {
}

public class MyImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        // 表示注入Car和Fish
        return new String[]{"com.t.Car", "com.t.Fish"};
    }
}
```
##### 导入ImportBeanDefinitionRegistrar实现类
导入该接口的实现类, 将会调用接口的default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)方法进行注册组件.
ImportBeanDefinitionRegistrar接口定义:
```
public interface ImportBeanDefinitionRegistrar {
	default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
			BeanNameGenerator importBeanNameGenerator) {

		registerBeanDefinitions(importingClassMetadata, registry);
	}

    /** 
     * importingClassMetadata: 当前类的注解信息, 
     * registry: bean定义注册类
     * 所有需要添加到容器中的组件使用registry进行手动注册.
     */
	default void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
	}
}
```
ImportBeanDefinitionRegistrar使用:
```java
@Configuration
@Import(MyImporter.class)
public class Conf {
}

public class MyImporter implements ImportBeanDefinitionRegistrar {
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        boolean car = registry.containsBeanDefinition("car");
        if (car) {
            // 如果含有car组件, 手动注入carFactory
            BeanDefinition beanDefinition = new RootBeanDefinition(CarFactory.class);
            registry.registerBeanDefinition("carFactory", beanDefinition);
        }
    }
}
```


### @Primary
> 如果存在多个组件, 表示注解所注释的组件为默认自动注入的组件.
> 用于类型和方法上.

```java
@Configuration
public class Conf {
    // 默认以类型注入的时候, 选择该组件
    @Bean
    @Primary
    public Car Audi() {
        return new Audi();
    }

    @Bean
    public Car Benz() {
        return new Benz();
    }
}

public class AutoWiredTest() {
    // 此时car是Audi
    @Autowired
    private Car car;
}
```


### FactoryBean
使用FactoryBean进行组件注册. 容器调用getObject()方法获取工厂产生的bean. 如果想要获取工厂bean本身, 则需要在beanName前添加`&`符号(即`&beanName`).

#### FactoryBean定义
```java
public interface FactoryBean<T> {
    String OBJECT_TYPE_ATTRIBUTE = "factoryBeanObjectType";

    @Nullable
    T getObject() throws Exception;

    @Nullable
    Class<?> getObjectType();

    default boolean isSingleton() {
        return true;
    }
}
```

#### FactoryBean使用
```java
@Configuration
public class Conf {
    // 容器将会同时注册carFactoryBean(调用getObject()产生)和工厂&carFactoryBean
    @Bean
    public CarFactoryBean carFactoryBean() {
        return new CarFactoryBean();
    }
}


public class CarFactoryBean implements FactoryBean<HH> {
    @Override
    public HH getObject() throws Exception {
        return new Car();
    }

    @Override
    public Class<?> getObjectType() {
        return Car.class;
    }
}
```

### InitializingBean和DisposableBean
> 除了使用@Bean的时候指定initMethod和destroyMethod还可以实现这两个接口完成同样功能.

InitializingBean和DisposableBean分别用于添加bean的初始化和销毁方法
#### 接口定义
```java
public interface InitializingBean {
    // 初始化一个bean之后调用该方法
	void afterPropertiesSet() throws Exception;

}

public interface DisposableBean {
    // 销毁一个bean之前调用该方法
	void destroy() throws Exception;
}
```
#### 接口使用
```java
@Component
public class Car implements InitializingBean, DisposableBean {
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("after init");
    }

    @Override
    public void destroy() throws Exception {
        System.out.println("before destroy");
    }
}
```

### @PostConstruct和@PreDestroy
> 第三种设置bean的初始化和销毁回调方法是使用jsr250定义的这两个注解.

使用方式:
```java
public class Car implements InitializingBean, DisposableBean {
    @PostConstruct
    public void afterPropertiesSet() {
        System.out.println("after init");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("before destroy");
    }
}
```

### BeanPostProcessor
> bean后置处理器, Spring提供该接口用于bean创建前后的一些处理. Spring中xxxAware接口, 就是借助该接口实现相关组件的注入.

#### BeanPostProcessor定义:
```java
public interface BeanPostProcessor {
    /**
     * 在任何初始化操作调用之前调用(例如InitializingBean的afterPropertiesSet或自定义的init-method或@PostConstruct注解之前调用).
     * bean的属性在调用该方法之前已经完成填充.
     */
	@Nullable
	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}

    // 在给定bean初始化之后调用(例如在InitializingBean的afterPropertiesSet或自定义的init-method或@PostConstruct注解之后调用)
	@Nullable
	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}
}
```

#### 自定义使用
```java
@Component
public class MyPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("before: beanName: " + beanName + ", bean: " + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("after: beanName: " + beanName + ", bean: " + bean);
        return bean;
    }
}
```

#### Spring底层使用举例
> 在业务类中实现Spring中的ApplicationAware, EnvironmentAware等接口, 都是通过ApplicationContextAwareProcessor调用相应的接口方法将组件注入到业务实现类中.
```java
class ApplicationContextAwareProcessor implements BeanPostProcessor {

	private final ConfigurableApplicationContext applicationContext;

	private final StringValueResolver embeddedValueResolver;


	/**
	 * Create a new ApplicationContextAwareProcessor for the given context.
	 */
	public ApplicationContextAwareProcessor(ConfigurableApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
		this.embeddedValueResolver = new EmbeddedValueResolver(applicationContext.getBeanFactory());
	}


	@Override
	@Nullable
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (!(bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
				bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
				bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware ||
				bean instanceof ApplicationStartupAware)) {
			return bean;
		}

		AccessControlContext acc = null;

		if (System.getSecurityManager() != null) {
			acc = this.applicationContext.getBeanFactory().getAccessControlContext();
		}

		if (acc != null) {
			AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
				invokeAwareInterfaces(bean);
				return null;
			}, acc);
		}
		else {
			invokeAwareInterfaces(bean);
		}

		return bean;
	}

    // 调用bean中实现相应Aware接口的方法将对应组件注入到bean中.
	private void invokeAwareInterfaces(Object bean) {
		if (bean instanceof EnvironmentAware) {
			((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
		}
		if (bean instanceof EmbeddedValueResolverAware) {
			((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
		}
		if (bean instanceof ResourceLoaderAware) {
			((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
		}
		if (bean instanceof ApplicationEventPublisherAware) {
			((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
		}
		if (bean instanceof MessageSourceAware) {
			((MessageSourceAware) bean).setMessageSource(this.applicationContext);
		}
		if (bean instanceof ApplicationStartupAware) {
			((ApplicationStartupAware) bean).setApplicationStartup(this.applicationContext.getApplicationStartup());
		}
		if (bean instanceof ApplicationContextAware) {
			((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
		}
	}

}
```


## 组件赋值

### @Value
> @Value注入属性到字段上. 元注解, 可以用于字段, 方法, 参数, 其他注解上.
> 该注解是在BeanPostProcessor(具体使用AutowiredAnnotationBeanPostProcessor实现)中进行处理, 所以无法在BeanPostProcessor中使用该注解.

使用方式:
- 基本的数值
- SpEL, #{}
- ${}, 读取配置文件中的属性
#### 基本数值
```java
@Component
public class Car() {
    // carName将被注入Audi
    @Value("Audi")
    private String carName;
}
```
#### SpEL表达式
```java
@Component
public class Car() {
    // price = 2
    @Value("#{1+1}")
    private int price;
}
```

#### 读取配置文件信息
如果读取的属性不存在时, 会将表达式当做字符串注入属性中. 如果启用了strict模式将会抛出异常.Spring 默认开启.  
也可以在表达式中指定默认值: `${property: defaultValue}`, 此时如果property不存在, 则将defaultValue注入属性中.
```java
@Component
public class Car() {
    // color = blue
    @Value("${car.color}")
    private String color;

    // height = 50
    @Value("${car.height: 50}")
    private int height;
}

// xxx.properties
car.color = blue
```

### @Autowired
> 元注解, 可以用于构造器, 方法, 参数, 字段, 其他注解. 由Spring的`BeanPostProcessor`实现, 所以无法在`BeanPostProcessor`中使用.
> 用于自动注入容器中的组件到相应的属性上. 其中required属性表示是否是否必须注入, 默认为true.
> @Autowired默认以类型进行匹配查找Bean. 若同一类型存在多个bean, 可以使用@Primary注解指定默认的注入bean. 也可以使用@Qualifier注解缩小限定范围.
> 尽管@Autowired可以使用在参数上, 但是Spring仅在Unit Jupiter这个spring的测试框架中支持.
> Although @Autowired can technically be declared on individual method or constructor parameters since Spring Framework 5.0, most parts of the framework ignore such declarations. The only part of the core Spring Framework that actively supports autowired parameters is the JUnit Jupiter support in the spring-test module (see the TestContext framework  reference documentation for details).
#### 字段注入
```java
@Component
public class Car() {
    @Autowired
    private CarType carType;
}
```
#### 方法注入
```java
@Component
public class Car() {
    private CarType carType;
    
    @Autowired
    public void setCarType(CarType carType) {
        this.carType= carType;
    }
}

```
#### 构造器注入
> 如果类中只有一个构造器(即使该构造方法是私有的), 如果不使用@Autowired注解, Spring也会自动使用该构造器进行注入.
```java
@Component
public class Car() {
    private CarType carType;
    
    @Autowired
    public CarType(CarType carType) {
        this.carType= carType;
    }
}
```

### @Qualifier
> 元注解, 可用于字段, 方法, 参数, 类型, 和其他注解.
> 用于缩小自动注入时的匹配范围, 例如有两个bean的类型都是Car, 则可以通过使用@Qualifier注解缩小范围

#### @Qualifier使用
```java
// 配置类
@Configuration
public class Conf() {
    // 如果未指定, 则Qualifier的value值默认为bean的名称.
    @Qualifier("audi")
    public Car Audi() {
        return new Audi();
    }
    @Qualifier("benz")
    public Car Benz() {
        return new Benz();
    }
}

public class Auto() {
    // 若不使用Qualifier注解, 会抛出异常, 无法自动注入
    @Qualifier("audi")
    @Autowired
    private Car car;
}
```

### @PropertySource
> 使用PropertySource可以加载外部配置文件.

引入配置文件后可以使用`${}`引用配置文件中的属性.
```java
@PropertySource({"classpath:/conf-dev.properties", "classpath:/conf-dev.properties"})
@Configuration
public class Conf() {

}
```

### @PropertySources
> 加载外部配置文件, 接收多个PropertySource注解.
#### @PropertySources接口定义
```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface PropertySources {

	PropertySource[] value();

}
```
#### @PropertySources使用
```java
@PropertySources({@PropertySource("classpath:/conf-dev.properties")})
public class Conf() {

}
```

### @Profile
> 表示指定配置激活时, 注解的组件才可以注册到容器中. 通常用于@Component及其复合注解和@Bean注解的方法上.

#### @Profile使用
@Profile默认使用default环境

```java
@Configuration
// 只有在激活了dev环境时才会注册car组件, Conf类会被注册到容器中
@Profile("dev")
public class Conf() {
    @Bean
    public Car car() {
        return new Car();
    }

    // 只有dev和test同时激活时, 才会注入audi组件
    @Profile("test")
    @Bean
    public Car audi() {
        return new Audi();
    }
}
```

---
