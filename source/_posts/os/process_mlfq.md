---
title: 进程调度策略-多级反馈队列
tags:
  - os
  - 进程调度
categories: os
date: 2021-01-27 16:40:22
---

## MLFQ(多级反馈队列)
> Multi-level Feedback Queue, MLFQ使用历史预测未来

MLFQ需要解决两方面的问题: 
1. 优化周转时间, 通常OS并不知道一个任务的运行时间, 而SJF, STCF都是基于已知任务运行时间的策略.
2. 优化响应时间, RR响应时间较短, 但是周转时间比较长.

### 基础规则
MLFQ拥有不同的队列, 每个队列都有不同的优先级. 在任意时间, 准备运行的任务在单独的队列中. MLFQ使用优先级决定将运行的任务.  
一个队列中可能存在多个任务, 这些任务拥有相同的优先级, 在这种情况下我们使用round-robin调度策略.  
综上, MLFQ基本规则:
- Rule1: If Priority(A) > Priority(B), A runs.
- Rule2: If priority(A) = Priority(B), A & B run in RR ({% post_link os/process_schedule %}).

MLFQ调度的关键在于如何设置优先级. MLFQ基于观察行为改变改变任务的优先级.MLFQ从任务运行历史中学习, 并根据历史预测任务的未来行为.

### 尝试1: 如何修改优先级
考虑系统中存在短时间运行的交互任务, 和长时间运行的cpu密集型(cpu-bound)任务. 尝试使用一下规则:
- Rule3: 每当有新任务到来, 将该任务置于最高优先级队列.
- Rule4a: 任务在运行期间用完了时间片, 减少该任务的优先级.
- Rule4b: 任务在时间片结束之前释放cpu, 保持该任务的优先级.

存在的问题:
1. 如果存在大量交互式任务, 其他长时间运行的任务可能会处于饥饿状态.
2. 用户可以写出程序欺骗调度器, 从而一直获得cpu使用权. 在任务的时间片用完之前, 请求I/O操作从而释放CPU, 一直获取高的优先级.
3. 一个任务可能会一直改变其行为. cpu密集型的任务可能会转换成交互式的任务. 当前的策略无法使得这些任务与其他交互式任务一样.

### 尝试2: 优先级提升
比较简单的方法解决饥饿问题是: 周期性地提升系统所有任务的优先级. 有许多方法可以实现该目标, 这里只简单地将任务置于最高优先级队列中. 于是:
- Rule5: 经过某个周期S, 将系统中的所有任务移动到最高优先队列中.

该规则解决了饥饿问题, 同时解决了cpu密集型任务转换成交互式任务的问题.

### 尝试3: 更好的统计
目标: 解决调度器欺骗问题.  
引起该问题原因是Rule4a和4b, 该规则定义了任务在时间片用完前释放cpu保持任务的优先级.  
为了解决该问题可以在MLFQ的每个层级都使用更好的统计cpu使用时间的方法. 调度器在每个层级都记录该层级任务的运行时间, 当任务在当前层级用完了分配的时间份额, 不管该任务是一次还是多次使用完该时间份额, 就降低该任务的优先级.   
由此, 重写Rule4a,4b:
- Rule4: 一旦一个任务在指定层级用完了所拥有的时间份额(不管是否释放cpu), 就降低其优先级.

### 其他问题
MLFQ重要的问题是如何参数化调度器.主要有一下几个问题:
1. 应该设置多少个队列
2. 每个队列的时间片长度是多少
3. 多久进行一次优先级的提升

大多数的MLFQ变种都允许改变队列的时间片长度. 高优先级队列时间片长度较短, 低优先级队列时间片长度较长.  

Solaris MLFQ实现提供了一些table配置进程优先级等信息(例如时间片长度, 提升任务优先级的时间).  
FreeBSD调度器基于进程使用cpu的时长计算任务的优先级.  
还有一些调度器将最高级队列用于操作系统工作, 用户任务只能使用其他优先级队列. 一些系统允许用户提供建议(advice)进行优先级设置, 例如: 通过`nice`命令行工具增加或减少任务优先级.

### 总结
MLFQ: 拥有多级队列, 使用反馈(feedback)决定任务的优先级. 根据任务的运行历史决定任务的优先级.  
MLFQ规则:
1. 如果A优先级 > B优先级, A运行
2. 如果A优先级 == B优先级, 使用`round-robin`调度策略
3. 当一个任务进入系统, 将其置于最高优先级队列
4. 一个任务在指定层级中的时间片份额耗尽, 降低其优先级
5. 经过某个周期S, 将所有的任务都置于最高优先级队列

MLFQ对于短时间运行的任务有着和`SJF/STCF`策略相似的性能. 对于长时间运行的cpu密集型任务, 有着公平的调度.  
使用MLFQ的操作系统: BSD UNIX及其后代, Solaris, Windows NT及后续Windows操作系统.

