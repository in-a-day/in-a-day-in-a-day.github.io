---
title: 地址空间
tags:
  - os
  - 内存虚拟化
categories: os
date: 2021-02-22 11:02:46
---

## 地址空间(address space)
> 物理内存抽象  

虚拟化内存, 使得应用程序认为其加载到特定的内存地址, 并独享非常大的地址空间.  
### 关键问题: 如何虚拟化内存?
```
操作系统如何在单一的物理内存上为多个运行的进程构建一个私有的, 可能很大的地址空间抽象.
```
### 目标
1. 透明, 程序不应该感知到内存被虚拟化的事实, 使其认为有独享的私有物理内存.
2. 效率, 操作系统应该在时间和空间上追求尽可能的高效. 为了实现高效, 通常需要硬件功能的支持(例如TLB).
3. 保护, 操作系统要确保进程受到保护, 不会受其他进程影响, 操作系统也不会受进程影响. 一个进程不应该访问其本身以外的内存地址空间. 保护为进程提供了隔离性, 每个进程都在自己独立的环境中运行, 避免其他出错或恶意进程的影响.

## 机制: 地址转换(address translation)
> 将虚拟地址转换为物理地址.  

实现cpu虚拟化时, 我们遵循了受限直接访问(Limited Direct Execution, LDE). LDE的基本思想是: 允许程序运行大部分指令直接访问硬件, 只在一些关键点(如进程发生系统调用或发生时钟中断), 由操作系统接入来确保"在正确的时间, 正确的地点, 做正确的事情". 为了实现高效的虚拟化, 操作系统尽量让程序自己运行, 同时通过在关键点的及时介入(interposing), 来保持对硬件的控制. 高效和控制是现代操作系统的两个主要的目标.

实现虚拟内存时, 也使用相似的策略, 在实现高效和控制的同时, 提供期望的虚拟化. 高效决定了需要硬件的支持, 一些简单的寄存器, TLB, 页表等. 控制表示操作系统确保应用程序只能访问他自己的内存空间. 同时还需要确保灵活性, 期望程序能以任何方式访问他自己的地址空间.

```
关键问题: 高效,灵活地虚拟化内存
如何高效实现内存虚拟化? 如何提供应用程序所需的灵活性? 如何控制应用程序可访问的内存位置, 从而确保程序的内存访问受到合理的限制? 如何高效的实现这一切?
```

### 动态(基于硬件)重定位: 基址界限(base and bound)
cpu 需要两个寄存器: 基址寄存器和界限寄存器. 进程使用的地址都是虚拟地址, 为了得到物理内存地址, 需要加上base寄存器内容:
$$ physical \ address = virtual \ address + base $$

如果内存超过bound界限则抛出异常. 有两种方式检查(逻辑上是等价的):
1. 在虚拟地址和基址寄存器内容求和之前检查.
2. 虚拟地址和基址寄存器求和之后检查.

由于地址重定位发生于运行时, 也称为动态重定位.

base和bound寄存器是芯片中的硬件结构, 每个cpu中存在一对. 也将cpu中负责内存地址转换的部分称为Memory management unit(MMU, 内存管理单元).   

#### 硬件支持
1. 与cpu虚拟化相同, 我们需要两种cpu模式. 特权模式(privileged mode, 也成内核模式, kernel mode), 可以访问整个机器资源. 用户模式(user mode), 只能做有限的操作.  
2. 硬件必须提供基址和界限寄存器(base and bounds register), 因此每个cpu的内存管理单元都需要这两个额外的寄存器. 硬件必须能检查地址是否可用, 通过界限寄存器和cpu的一些电路实现.  
3. 硬件还需提供一些特殊的指令, 用于修改基址寄存器和界限寄存器, 允许操作系统在切换进程时改变他们. 这些指令是特权指令, 只有在内核模式下使用.
4. 最后, 用户程序试图非法访问内存(越界访问时), cpu必须能够产生异常.同时安排操作系统进行异常处理. cpu需要提供方法通知处理异常程序的位置, 因此需要另外的一些特权指令.

硬件要求 | 解释
--- | ---
特权模式 | 以防用户模式的进程执行特权操作
基址/界限寄存器 | 每个cpu需要一堆寄存器支持地址转换和界限检查
修改基址/界限寄存器的特权指令 | 用户程序运行前, 操作系统需要设置这些值
注册异常处理的特权指令 | 操作系统需通知硬件发生异常执行的代码
能够触发异常 | 进程试图使用特权指令或越界的内存

#### 操作系统支持
1. 进程创建时, 操作系统必须为进程的地址空间寻找合适的物理内存空间. 假设鼎城的地址空间小于物理内存,且大小相同. 操作系统可将物理内存看成一组槽块, 标记空间或已用. 当创建新进程时, 查找该数据结构(常称空闲列表, free list), 为新地址空间查找位置.
2. 进程终止时, 操作系统应该回收其所有内存. 将内存放回空闲列表, 并根据需求清除相关的数据结构.
3. 上下文切换时, 由于每个cpu只有同一个基址寄存器和一个界限寄存器. 对于每个进程来说, 他们的值都不相同, 操作系统必须保存和恢复基址和界限寄存器. 所以当操作系统决定中止当前进程时, 需要将当前的基址和界限寄存器保存在内存中, 放入每个进程都有的结构中, 例如进程控制块(PCB). 操作系统恢复执行(或首次)进程时, 也必须给基址和界限寄存器设置正确的值.

操作系统要求 | 解释
--- | ---
内存管理 | 新进程分配内存  终止进程回收内存  通常通过空闲列表管理
基址/界限管理 | 上线文切换时正确设置基址/界限寄存器
异常处理 | 异常发生时执行的代码

### 分段
基址界限寄存器, 会导致有一大块的空闲空间.
```
关键问题: 怎样支持大地址空间
如何支持大地址空间, 同时栈和堆之间有大量的空闲空间?
```
#### 分段: 泛化的基址/界限










